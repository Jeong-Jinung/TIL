## REST API 버전을 지정하는 4가지 일반적인 방법

###**1. URI 경로를 통한 버전 관리**

`http://www.example.com/api/1/products`

REST API 버전을 지정하는 한 가지 방법은 URI 경로에 버전 번호를 포함하는 것입니다.  
API의 내부 버전은 1.2.3 형식을 사용하므로 다음과 같습니다.  

`MAJOR.MINOR.PATCH`

- **MAJOR 버전** : URI에 사용된 버전으로 API의 주요 변경 사항을 나타냅니다.  
내부적으로 새 주 버전은 새 API 생성을 의미하며 버전 번호는 올바른 호스트로 라우팅하는 데 사용됩니다.
- **MINOR & PATCH 버전** : 클라이언트에 투명하며 내부적으로 이전 버전과 호환되는 업데이트에 사용됩니다.  
일반적으로 클라이언트에게 새로운 기능이나 버그 수정에 대해 알리기 위해 변경 로그로 전달됩니다.

이 솔루션은 종종 URI 라우팅을 사용하여 API의 특정 버전을 가리킵니다.  
캐시 키(이 경우 URI)는 버전별로 변경되기 때문에 클라이언트는 리소스를 쉽게 캐시할 수 있습니다.  
REST API의 새 버전이 릴리스되면 캐시의 새 항목으로 인식됩니다.

- **장점** : 클라이언트가 리소스를 쉽게 캐시할 수 있습니다.
- **단점** : 이 솔루션은 주요 변경 사항을 도입하는 것이 전체 API를 분기하는 것을 의미하므로  
코드 기반에서 상당히 큰 공간을 차지합니다.

  
###**2. 쿼리파라미터를 통한 버전 관리**  
`http://www.example.com/api/products?version=1`  

REST API 버전 관리를 위한 또 다른 옵션은 버전 번호를 쿼리 매개변수로 포함하는 것입니다.  
이것은 구현 관점에서 API 버전을 관리하는 간단한 방법입니다.  
- **장점** : API 버전을 지정하는 간단한 방법이며 최신 버전으로 기본 설정하기 쉽습니다.
- **단점** : 쿼리 매개변수는 요청을 적절한 API 버전으로 라우팅하는 데 사용하기가 더 어렵습니다.

###**3. 커스텀 헤더를 통한 버전 관리**
```text
curl -H “Accepts-version: 1.0”
http://www.example.com/api/products
```
REST API는 버전 번호가 속성으로 포함된 사용자 정의 헤더를 제공하여 버전을 관리할 수도 있습니다.  
이 방법과 이전 두 가지 방법의 주요 차이점은 URI가 버전 정보로 복잡하지 않다는 것입니다.
- **장점** : URI를 버전 정보로 복잡하게 만들지 않습니다.
- **단점** : 사용자 정의 헤더가 필요합니다.

###**3. 콘텐츠 협상을 통한 버전 관리**
우리가 다루고 있는 마지막 전략은 콘텐츠 협상을 통한 버전 관리입니다.  

이 접근 방식을 사용하면 전체 API의 버전을 관리하는 대신 단일 리소스 표현의 버전을 관리할 수 있으므로  
버전 관리를 보다 세부적으로 제어할 수 있습니다. 또한 새 버전을 생성할 때  
전체 애플리케이션을 분기할 필요가 없기 때문에 코드 기반에서 더 작은 공간을 차지합니다.  
이 접근 방식의 또 다른 이점은 URI 경로를 통해 버전 관리를 통해 도입된 URI 라우팅 규칙을 구현할 필요가 없다는 것입니다.
- **장점** : 전체 API의 버전을 관리하는 대신 단일 리소스 표현의 버전을 지정할 수 있어  
  버전 관리를 보다 세부적으로 제어할 수 있습니다. 더 작은 설치 공간을 만듭니다.  
  URI 라우팅 규칙을 구현할 필요가 없습니다.
- **단점** : 미디어 유형이 있는 HTTP 헤더를 요구하면 브라우저를 사용하여 API를 테스트하고 탐색하기가 더 어려워집니다.

###**요약**
버전 관리는 API 설계의 중요한 부분입니다.  
개발자는 새로운 업데이트가 출시될 때 클라이언트의 애플리케이션을 중단하지 않고 API를 개선할 수 있습니다.  

콘텐츠 협상은 전체 API의 버전을 지정하는 대신 리소스 표현의 버전을 지정하기 때문에 보다 세분화된 접근 방식이지만  
클라이언트와 개발자 모두에게 높은 구현 비용이 수반됩니다. 기본적으로 제공하는 라이브러리가 거의 없기 때문에 
콘텐츠 협상을 처음부터 구현해야 하는 경우가 많습니다. 다른 접근 방식은 구현 및 사용이 더 쉽지만  
API 계약에 주요 변경 사항을 도입하는 높은 비용으로 인해 개발자의 리팩토링 능력이 제한됩니다.